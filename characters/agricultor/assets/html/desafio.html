<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Planta√ß√£o Fora de Rota üåæ</title>
<style>
  body {
    margin: 0;
    background: linear-gradient(#e7f5e7, #cfe9cf); /* sem foto de fundo */
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: "Arial", sans-serif;
    user-select: none;
  }

  .campo {
    position: relative;
    width: 92vw;
    max-width: 900px;
    aspect-ratio: 2.2 / 1; /* responsivo e centralizado */
    border: 3px solid #4a3c1a;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.35), 0 10px 24px rgba(0,0,0,0.15);
    /* Ilustra√ß√£o de caminhos de plantio (sulcos) */
    background:
      /* trilhos claros entre os sulcos */
      repeating-linear-gradient(
        0deg,
        rgba(255,255,255,0.08) 0 4px,
        rgba(0,0,0,0) 4px 64px
      ),
      /* faixas de solo */
      repeating-linear-gradient(
        0deg,
        #6a4f32 0 32px,
        #7a5e3b 32px 64px
      );
  }
  .campo::after {
    content: "";
    position: absolute; inset: 0;
    pointer-events: none;
    background: radial-gradient(120% 140% at 50% 50%, rgba(0,0,0,0) 55%, rgba(0,0,0,0.25) 100%);
  }

  .linha {
    position: absolute;
    height: 8px;
    width: 120px;
    background: #2d8a26;
    border-radius: 999px;
    cursor: pointer;
    transition: transform 0.3s ease, background 0.3s ease, box-shadow 0.2s ease;
    box-shadow: 0 0 0 rgba(0,0,0,0);
  }

  .linha.errada {
    transform: rotate(45deg);
    background: #c62828;
  }

  .mensagem {
    position: absolute;
    bottom: 20px;
    left: 0;
    right: 0;
    text-align: center;
    font-size: 1.4em;
    font-weight: bold;
    color: #fff;
    text-shadow: 2px 2px 4px #000;
  }
  .hud-bottom {
    position: absolute;
    left: 0; right: 0; bottom: 0;
    display: flex; align-items: center; gap: 12px;
    padding: 10px 12px;
    background: linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,0.30));
    color: #fff; z-index: 5;
  }
  .hud-bottom .info { flex: 1; font-weight: 700; text-shadow: 2px 2px 4px #000; }
  .hud-bottom .btn { background: rgba(62,123,46,0.95); color: #fff; border: none; padding: 8px 14px; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.25); font-weight: 700; }
  .hud-bottom .btn.secondary { background: rgba(32,78,24,0.95); }

  .trator {
    position: absolute;
    width: 42px; height: 42px;
    transform: translate(-40px, -8px); /* inicia √† esquerda do primeiro segmento */
    filter: drop-shadow(0 4px 8px rgba(0,0,0,.45));
    transition: transform 0.05s linear; /* movimentos mais r√°pidos para suavidade cont√≠nua */
    pointer-events: none; /* n√£o atrapalha cliques nas linhas */
    z-index: 4;
  }
  .trator.fail { animation: shake .35s linear 3; }
  @keyframes shake { 0%,100%{ transform: translate(var(--tx), var(--ty)) } 25%{ transform: translate(calc(var(--tx) + 4px), var(--ty)) } 50%{ transform: translate(calc(var(--tx) - 4px), var(--ty)) } 75%{ transform: translate(calc(var(--tx) + 2px), var(--ty)) } }
</style>
</head>
<body>

<div class="campo">
  <div class="mensagem">Corrija as linhas para alinhar a planta√ß√£o!</div>
  <div class="hud-bottom">
    <button class="btn" id="btnIniciar">‚ñ∂Ô∏è Iniciar</button>
  </div>
</div>

<script>
const campo = document.querySelector('.campo');
const mensagem = document.querySelector('.mensagem');
let btnFinalizar = null;
let btnReiniciarDinamico = null;
const btnIniciar = document.getElementById('btnIniciar');

let linhas = [];
let linhasPorRow = []; // matriz [row] => segmentos da linha
let tratores = [];     // um trator por linha (img)
let emExecucao = false;
let stopAll = false;

// Configura√ß√£o do grid
const COLS = 9;            // colunas
const ROWS = 4;            // linhas/caminhos
const OFFSET_X = 60;       // margem esquerda
const OFFSET_Y = 60;       // margem superior
const GAP_X = 85;          // espa√ßamento horizontal ajustado para uniformidade
const GAP_Y = 70;          // espa√ßamento vertical mais equilibrado

// Dimens√µes usadas para posicionamento
const TRACTOR_W = 42;
const TRACTOR_H = 42;
const SEG_H = 8;
const SAFE_GAP = 8; // px antes do segmento errado para parar

function criarLinhas() {
  // limpar segmentos e tratores anteriores
  campo.querySelectorAll('.linha').forEach(l => l.remove());
  campo.querySelectorAll('img.trator').forEach(t => t.remove());

  linhas = [];
  linhasPorRow = Array.from({length: ROWS}, () => []);
  tratores = [];
  emExecucao = false;
  stopAll = false;
  limparBotoesDinamicos();

  for (let i = 0; i < COLS; i++) {
    for (let j = 0; j < ROWS; j++) {
      const linha = document.createElement('div');
      linha.classList.add('linha');
      const top = OFFSET_Y + j * GAP_Y;
      const left = OFFSET_X + i * GAP_X;
      linha.style.top = `${top}px`;
      linha.style.left = `${left}px`;
      campo.appendChild(linha);
      linhas.push(linha);
      linhasPorRow[j].push(linha);
    }
  }

  // Definir sempre os MESMOS 6 segmentos errados (primeiro de cada linha permanece correto)
  // Limpa qualquer marca√ß√£o anterior
  linhas.forEach(l => l.classList.remove('errada'));

  // Mapa fixo: {row: [colunas_erradas]}
  const ERR_MAP = {
    0: [2, 6], // linha 0: colunas 2 e 6
    1: [4, 7], // linha 1: colunas 4 e 7
    2: [3],    // linha 2: coluna 3
    3: [5]     // linha 3: coluna 5
  };

  Object.entries(ERR_MAP).forEach(([rowStr, cols]) => {
    const r = parseInt(rowStr, 10);
    cols.forEach(c => {
      // seguran√ßa: evita marcar a primeira coluna e respeita limites
      if (c > 0 && linhasPorRow[r] && linhasPorRow[r][c]) {
        linhasPorRow[r][c].classList.add('errada');
      }
    });
  });

  // Garantir que o layout est√° pronto antes de posicionar os tratores
  setTimeout(() => {
    for (let r = 0; r < ROWS; r++) {
      const primeiro = linhasPorRow[r][0];
      const t = document.createElement('img');
      t.className = 'trator';
      t.src = 'https://cdn-icons-png.flaticon.com/512/2781/2781093.png';
      t.alt = 'Trator';

      const rectCampo = campo.getBoundingClientRect();
      const rectSeg = primeiro.getBoundingClientRect();
      const tx = rectSeg.left - rectCampo.left - (TRACTOR_W + 6); // um pouco √† esquerda do primeiro segmento
      const ty = rectSeg.top - rectCampo.top + (SEG_H/2) - (TRACTOR_H/2); // centraliza na altura do segmento
      t.style.setProperty('--tx', tx + 'px');
      t.style.setProperty('--ty', ty + 'px');
      t.style.transform = `translate(${tx}px, ${ty}px)`;

      campo.appendChild(t);
      tratores.push(t);
    }
  }, 80);

  // listeners de clique nas linhas (n√£o permite editar durante corrida)
  linhas.forEach(linha => {
    linha.addEventListener('click', () => {
      if (emExecucao) return;
      linha.classList.toggle('errada');
      mensagem.textContent = 'Ajuste todos os segmentos e clique em ‚ñ∂Ô∏è Iniciar';
    });
  });

  mensagem.textContent = 'Corrija as linhas para alinhar a planta√ß√£o!';
}

function limparBotoesDinamicos() {
  if (btnFinalizar) btnFinalizar.remove();
  if (btnReiniciarDinamico) btnReiniciarDinamico.remove();
}

function criarBotaoFinalizar() {
  limparBotoesDinamicos();
  btnFinalizar = document.createElement('button');
  btnFinalizar.textContent = '‚úÖ Finalizar';
  btnFinalizar.className = 'btn';
  btnFinalizar.style.position = 'absolute';
  btnFinalizar.style.bottom = '70px';
  btnFinalizar.style.left = '50%';
  btnFinalizar.style.transform = 'translateX(-50%)';
  btnFinalizar.style.padding = '10px 18px';
  btnFinalizar.style.fontSize = '16px';
  btnFinalizar.addEventListener('click', () => {
    mensagem.textContent = 'üåü Parab√©ns! Voc√™ concluiu o desafio!';
    btnFinalizar.remove();
  });
  campo.appendChild(btnFinalizar);
}

function criarBotaoReiniciarDinamico() {
  limparBotoesDinamicos();
  btnReiniciarDinamico = document.createElement('button');
  btnReiniciarDinamico.textContent = 'üîÑ Reiniciar Desafio';
  btnReiniciarDinamico.className = 'btn secondary';
  btnReiniciarDinamico.style.position = 'absolute';
  btnReiniciarDinamico.style.bottom = '70px';
  btnReiniciarDinamico.style.left = '50%';
  btnReiniciarDinamico.style.transform = 'translateX(-50%)';
  btnReiniciarDinamico.style.padding = '10px 18px';
  btnReiniciarDinamico.style.fontSize = '16px';
  btnReiniciarDinamico.addEventListener('click', () => {
    criarLinhas();
    mensagem.textContent = 'Corrija as linhas e clique em ‚ñ∂Ô∏è Iniciar novamente';
  });
  campo.appendChild(btnReiniciarDinamico);
}

function verificarVitoriaGlobal() {
  // Vit√≥ria se todas as linhas estiverem sem erro e todos tratores chegarem
  const todasCorretas = linhas.every(l => !l.classList.contains('errada'));
  if (todasCorretas) {
    mensagem.textContent = 'üåæ Desafio cumprido! Todos os tratores chegaram ao fim!';
    criarBotaoFinalizar();
  }
}

function percorrerLinha(trator, rowIndex) {
  return new Promise((resolve) => {
    const rectCampo = campo.getBoundingClientRect();
    const segmentos = linhasPorRow[rowIndex];

    // Y fixo baseado no primeiro segmento da linha (centro do caminho)
    const baseR = segmentos[0].getBoundingClientRect();
    const yCentroLinha = baseR.top - rectCampo.top + (SEG_H/2) - (TRACTOR_H/2);

    // Construir pontos somente com varia√ß√£o em X, Y fixo
    let pontos = [];
    for (let i = 0; i < segmentos.length; i++) {
      const seg = segmentos[i];
      const r = seg.getBoundingClientRect();
      pontos.push({
        x: r.left - rectCampo.left + (r.width/2) - (TRACTOR_W/2),
        y: yCentroLinha,
        errado: seg.classList.contains('errada')
      });
    }
    // ponto final um pouco √† direita do √∫ltimo
    const rLast = segmentos[segmentos.length - 1].getBoundingClientRect();
    pontos.push({
      x: rLast.right - rectCampo.left + 12 - (TRACTOR_W/2),
      y: yCentroLinha,
      errado: false
    });

    // Restaurar transi√ß√£o suave ao iniciar
    tratores.forEach(t => t.style.transition = 'transform 0.05s linear');

    const velocidade = 2; // px por frame
    let i = 0;

    function mover() {
      if (stopAll) { resolve(new Error('parado')); return; }
      if (i >= pontos.length - 1) { resolve(); return; }

      const atual = pontos[i];
      const proximo = pontos[i + 1];

      // Se o PR√ìXIMO segmento √© errado, calcular um ponto de parada ANTES da borda esquerda do segmento
      if (proximo.errado) {
        const segWrong = segmentos[i + 1];
        const rw = segWrong.getBoundingClientRect();
        // parar antes da borda esquerda do segmento errado
        let stopX = rw.left - rectCampo.left - (TRACTOR_W/2) - SAFE_GAP;
        if (stopX < atual.x) stopX = atual.x; // seguran√ßa

        const dx2 = stopX - atual.x;
        const dist2 = Math.abs(dx2);
        const passos2 = Math.max(1, Math.ceil(dist2 / velocidade));
        let p2 = 0;

        function ateAntesDoErrado() {
          if (stopAll) { resolve(new Error('parado')); return; }
          if (p2 >= passos2) {
            // Posiciona exatamente antes do segmento errado
            trator.style.transform = `translate(${stopX}px, ${yCentroLinha}px)`;
            // Atualiza as vari√°veis usadas na anima√ß√£o de shake para N√ÉO voltar ao in√≠cio
            trator.style.setProperty('--tx', `${stopX}px`);
            trator.style.setProperty('--ty', `${yCentroLinha}px`);
            // Agora aplica o estado de falha
            trator.classList.add('fail');
            // congela TODOS
            stopAll = true;
            tratores.forEach(t => t.style.transition = 'none');
            mensagem.textContent = '‚ùå Um dos tratores encontrou um trecho torto!';
            criarBotaoReiniciarDinamico();
            resolve(Object.assign(new Error('Falha no percurso'), { __fail: true }));
            return;
          }
          const x2 = atual.x + (dx2 * p2 / passos2);
          trator.style.transform = `translate(${x2}px, ${yCentroLinha}px)`;
          p2++;
          requestAnimationFrame(ateAntesDoErrado);
        }

        requestAnimationFrame(ateAntesDoErrado);
        return; // n√£o seguir para o pr√≥ximo ponto
      }

      // Caso normal
      const dx = proximo.x - atual.x;
      const dist = Math.abs(dx);
      const passos = Math.max(1, Math.ceil(dist / velocidade));
      let passo = 0;

      function animar() {
        if (stopAll) { resolve(new Error('parado')); return; }
        if (passo >= passos) { i++; requestAnimationFrame(mover); return; }
        const x = atual.x + (dx * passo / passos);
        trator.style.transform = `translate(${x}px, ${yCentroLinha}px)`;
        passo++;
        requestAnimationFrame(animar);
      }

      requestAnimationFrame(animar);
    }

    mover();
  });
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// Bot√µes
document.addEventListener('click', (e) => {
  if (e.target === btnIniciar) iniciarCorrida();
});

async function iniciarCorrida() {
  if (emExecucao) return;
  emExecucao = true;
  stopAll = false;
  mensagem.textContent = 'üöú Tratores em movimento‚Ä¶';

  // desabilitar edi√ß√µes durante o percurso
  linhas.forEach(l => l.style.pointerEvents = 'none');
  btnIniciar.disabled = true;

  try {
    // Percorre as linhas em paralelo
    const promessas = tratores.map((tr, r) => percorrerLinha(tr, r));
    const resultados = await Promise.all(promessas.map(p => p.catch(e => e)));
    const fracassou = resultados.some(x => x && x.__fail);

    if (fracassou) {
      mensagem.textContent = '‚ùå Um dos tratores encontrou um trecho torto!';
      criarBotaoReiniciarDinamico();
    } else {
      verificarVitoriaGlobal();
    }
  } finally {
    // Reabilitar intera√ß√µes
    linhas.forEach(l => l.style.pointerEvents = '');
    btnIniciar.disabled = false;
    emExecucao = false;
  }
}

// Inicializa√ß√£o
criarLinhas();
</script>

</body>
</html>