<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Off-Route Planting üåæ</title>
<style>
  body {
    margin: 0;
    background: linear-gradient(#e7f5e7, #cfe9cf); /* no background photo */
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: "Arial", sans-serif;
    user-select: none;
  }

  .campo {
    position: relative;
    width: 92vw;
    max-width: 900px;
    aspect-ratio: 2.2 / 1; /* responsive and centered */
    border: 3px solid #4a3c1a;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.35), 0 10px 24px rgba(0,0,0,0.15);
    /* Planting path illustration (furrows) */
    background:
      /* light tracks between furrows */
      repeating-linear-gradient(
        0deg,
        rgba(255,255,255,0.08) 0 4px,
        rgba(0,0,0,0) 4px 64px
      ),
      /* soil strips */
      repeating-linear-gradient(
        0deg,
        #6a4f32 0 32px,
        #7a5e3b 32px 64px
      );
  }
  .campo::after {
    content: "";
    position: absolute; inset: 0;
    pointer-events: none;
    background: radial-gradient(120% 140% at 50% 50%, rgba(0,0,0,0) 55%, rgba(0,0,0,0.25) 100%);
  }

  .linha {
    position: absolute;
    height: 8px;
    width: 120px;
    background: #2d8a26;
    border-radius: 999px;
    cursor: pointer;
    transition: transform 0.3s ease, background 0.3s ease, box-shadow 0.2s ease;
    box-shadow: 0 0 0 rgba(0,0,0,0);
  }

  .linha.errada {
    transform: rotate(45deg);
    background: #c62828;
  }

  .mensagem {
    position: absolute;
    bottom: 20px;
    left: 0;
    right: 0;
    text-align: center;
    font-size: 1.4em;
    font-weight: bold;
    color: #fff;
    text-shadow: 2px 2px 4px #000;
  }
  .hud-bottom {
    position: absolute;
    left: 0; right: 0; bottom: 0;
    display: flex; align-items: center; gap: 12px;
    padding: 10px 12px;
    background: linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,0.30));
    color: #fff; z-index: 5;
  }
  .hud-bottom .info { flex: 1; font-weight: 700; text-shadow: 2px 2px 4px #000; }
  .hud-bottom .btn { background: rgba(62,123,46,0.95); color: #fff; border: none; padding: 8px 14px; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.25); font-weight: 700; }
  .hud-bottom .btn.secondary { background: rgba(32,78,24,0.95); }

  .trator {
    position: absolute;
    width: 42px; height: 42px;
    transform: translate(-40px, -8px); /* starts to the left of the first segment */
    filter: drop-shadow(0 4px 8px rgba(0,0,0,.45));
    transition: transform 0.05s linear; /* faster movements for continuous smoothness */
    pointer-events: none; /* doesn't interfere with line clicks */
    z-index: 4;
  }
  .trator.fail { animation: shake .35s linear 3; }
  @keyframes shake { 0%,100%{ transform: translate(var(--tx), var(--ty)) } 25%{ transform: translate(calc(var(--tx) + 4px), var(--ty)) } 50%{ transform: translate(calc(var(--tx) - 4px), var(--ty)) } 75%{ transform: translate(calc(var(--tx) + 2px), var(--ty)) } }
</style>
</head>
<body>

<div class="campo">
  <div class="mensagem">Fix the lines to align the planting!</div>
  <div class="hud-bottom">
    <button class="btn" id="btnIniciar">‚ñ∂Ô∏è Start</button>
  </div>
</div>

<script>
const campo = document.querySelector('.campo');
const mensagem = document.querySelector('.mensagem');
let btnFinalizar = null;
let btnReiniciarDinamico = null;
const btnIniciar = document.getElementById('btnIniciar');

let linhas = [];
let linhasPorRow = []; // matrix [row] => line segments
let tratores = [];     // one tractor per line (img)
let emExecucao = false;
let stopAll = false;

// Grid configuration
const COLS = 9;            // columns
const ROWS = 4;            // lines/paths
const OFFSET_X = 60;       // left margin
const OFFSET_Y = 60;       // top margin
const GAP_X = 85;          // horizontal spacing adjusted for uniformity
const GAP_Y = 70;          // more balanced vertical spacing

// Dimensions used for positioning
const TRACTOR_W = 42;
const TRACTOR_H = 42;
const SEG_H = 8;
const SAFE_GAP = 8; // px before wrong segment to stop

function criarLinhas() {
  // clear previous segments and tractors
  campo.querySelectorAll('.linha').forEach(l => l.remove());
  campo.querySelectorAll('img.trator').forEach(t => t.remove());

  linhas = [];
  linhasPorRow = Array.from({length: ROWS}, () => []);
  tratores = [];
  emExecucao = false;
  stopAll = false;
  limparBotoesDinamicos();

  for (let i = 0; i < COLS; i++) {
    for (let j = 0; j < ROWS; j++) {
      const linha = document.createElement('div');
      linha.classList.add('linha');
      const top = OFFSET_Y + j * GAP_Y;
      const left = OFFSET_X + i * GAP_X;
      linha.style.top = `${top}px`;
      linha.style.left = `${left}px`;
      campo.appendChild(linha);
      linhas.push(linha);
      linhasPorRow[j].push(linha);
    }
  }

  // Always define the SAME 6 wrong segments (first of each line remains correct)
  // Clear any previous marking
  linhas.forEach(l => l.classList.remove('errada'));

  // Fixed map: {row: [wrong_columns]}
  const ERR_MAP = {
    0: [2, 6], // line 0: columns 2 and 6
    1: [4, 7], // line 1: columns 4 and 7
    2: [3],    // line 2: column 3
    3: [5]     // line 3: column 5
  };

  Object.entries(ERR_MAP).forEach(([rowStr, cols]) => {
    const r = parseInt(rowStr, 10);
    cols.forEach(c => {
      // safety: avoids marking the first column and respects limits
      if (c > 0 && linhasPorRow[r] && linhasPorRow[r][c]) {
        linhasPorRow[r][c].classList.add('errada');
      }
    });
  });

  // Ensure layout is ready before positioning tractors
  setTimeout(() => {
    for (let r = 0; r < ROWS; r++) {
      const primeiro = linhasPorRow[r][0];
      const t = document.createElement('img');
      t.className = 'trator';
      t.src = 'https://cdn-icons-png.flaticon.com/512/2781/2781093.png';
      t.alt = 'Tractor';

      const rectCampo = campo.getBoundingClientRect();
      const rectSeg = primeiro.getBoundingClientRect();
      const tx = rectSeg.left - rectCampo.left - (TRACTOR_W + 6); // a bit to the left of the first segment
      const ty = rectSeg.top - rectCampo.top + (SEG_H/2) - (TRACTOR_H/2); // centers on segment height
      t.style.setProperty('--tx', tx + 'px');
      t.style.setProperty('--ty', ty + 'px');
      t.style.transform = `translate(${tx}px, ${ty}px)`;

      campo.appendChild(t);
      tratores.push(t);
    }
  }, 80);

  // line click listeners (doesn't allow editing during run)
  linhas.forEach(linha => {
    linha.addEventListener('click', () => {
      if (emExecucao) return;
      linha.classList.toggle('errada');
      mensagem.textContent = 'Adjust all segments and click ‚ñ∂Ô∏è Start';
    });
  });

  mensagem.textContent = 'Fix the lines to align the planting!';
}

function limparBotoesDinamicos() {
  if (btnFinalizar) btnFinalizar.remove();
  if (btnReiniciarDinamico) btnReiniciarDinamico.remove();
}

function criarBotaoFinalizar() {
  limparBotoesDinamicos();
  btnFinalizar = document.createElement('button');
  btnFinalizar.textContent = '‚úÖ Finish';
  btnFinalizar.className = 'btn';
  btnFinalizar.style.position = 'absolute';
  btnFinalizar.style.bottom = '70px';
  btnFinalizar.style.left = '50%';
  btnFinalizar.style.transform = 'translateX(-50%)';
  btnFinalizar.style.padding = '10px 18px';
  btnFinalizar.style.fontSize = '16px';
  btnFinalizar.addEventListener('click', () => {
    mensagem.textContent = 'üåü Congratulations! You completed the challenge!';
    btnFinalizar.remove();
  });
  campo.appendChild(btnFinalizar);
}

function criarBotaoReiniciarDinamico() {
  limparBotoesDinamicos();
  btnReiniciarDinamico = document.createElement('button');
  btnReiniciarDinamico.textContent = 'üîÑ Restart Challenge';
  btnReiniciarDinamico.className = 'btn secondary';
  btnReiniciarDinamico.style.position = 'absolute';
  btnReiniciarDinamico.style.bottom = '70px';
  btnReiniciarDinamico.style.left = '50%';
  btnReiniciarDinamico.style.transform = 'translateX(-50%)';
  btnReiniciarDinamico.style.padding = '10px 18px';
  btnReiniciarDinamico.style.fontSize = '16px';
  btnReiniciarDinamico.addEventListener('click', () => {
    criarLinhas();
    mensagem.textContent = 'Fix the lines and click ‚ñ∂Ô∏è Start again';
  });
  campo.appendChild(btnReiniciarDinamico);
}

function verificarVitoriaGlobal() {
  // Victory if all lines are error-free and all tractors arrive
  const todasCorretas = linhas.every(l => !l.classList.contains('errada'));
  if (todasCorretas) {
    mensagem.textContent = 'üåæ Challenge completed! All tractors reached the end!';
    criarBotaoFinalizar();
  }
}

function percorrerLinha(trator, rowIndex) {
  return new Promise((resolve) => {
    const rectCampo = campo.getBoundingClientRect();
    const segmentos = linhasPorRow[rowIndex];

    // Fixed Y based on first segment of the line (path center)
    const baseR = segmentos[0].getBoundingClientRect();
    const yCentroLinha = baseR.top - rectCampo.top + (SEG_H/2) - (TRACTOR_H/2);

    // Build points only with X variation, fixed Y
    let pontos = [];
    for (let i = 0; i < segmentos.length; i++) {
      const seg = segmentos[i];
      const r = seg.getBoundingClientRect();
      pontos.push({
        x: r.left - rectCampo.left + (r.width/2) - (TRACTOR_W/2),
        y: yCentroLinha,
        errado: seg.classList.contains('errada')
      });
    }
    // final point a bit to the right of the last one
    const rLast = segmentos[segmentos.length - 1].getBoundingClientRect();
    pontos.push({
      x: rLast.right - rectCampo.left + 12 - (TRACTOR_W/2),
      y: yCentroLinha,
      errado: false
    });

    // Restore smooth transition when starting
    tratores.forEach(t => t.style.transition = 'transform 0.05s linear');

    const velocidade = 2; // px per frame
    let i = 0;

    function mover() {
      if (stopAll) { resolve(new Error('stopped')); return; }
      if (i >= pontos.length - 1) { resolve(); return; }

      const atual = pontos[i];
      const proximo = pontos[i + 1];

      // If the NEXT segment is wrong, calculate a stop point BEFORE the left edge of the segment
      if (proximo.errado) {
        const segWrong = segmentos[i + 1];
        const rw = segWrong.getBoundingClientRect();
        // stop before the left edge of the wrong segment
        let stopX = rw.left - rectCampo.left - (TRACTOR_W/2) - SAFE_GAP;
        if (stopX < atual.x) stopX = atual.x; // safety

        const dx2 = stopX - atual.x;
        const dist2 = Math.abs(dx2);
        const passos2 = Math.max(1, Math.ceil(dist2 / velocidade));
        let p2 = 0;

        function ateAntesDoErrado() {
          if (stopAll) { resolve(new Error('stopped')); return; }
          if (p2 >= passos2) {
            // Position exactly before the wrong segment
            trator.style.transform = `translate(${stopX}px, ${yCentroLinha}px)`;
            // Update variables used in shake animation to NOT return to start
            trator.style.setProperty('--tx', `${stopX}px`);
            trator.style.setProperty('--ty', `${yCentroLinha}px`);
            // Now apply failure state
            trator.classList.add('fail');
            // freeze ALL
            stopAll = true;
            tratores.forEach(t => t.style.transition = 'none');
            mensagem.textContent = '‚ùå One of the tractors found a crooked section!';
            criarBotaoReiniciarDinamico();
            resolve(Object.assign(new Error('Path failure'), { __fail: true }));
            return;
          }
          const x2 = atual.x + (dx2 * p2 / passos2);
          trator.style.transform = `translate(${x2}px, ${yCentroLinha}px)`;
          p2++;
          requestAnimationFrame(ateAntesDoErrado);
        }

        requestAnimationFrame(ateAntesDoErrado);
        return; // don't follow to next point
      }

      // Normal case
      const dx = proximo.x - atual.x;
      const dist = Math.abs(dx);
      const passos = Math.max(1, Math.ceil(dist / velocidade));
      let passo = 0;

      function animar() {
        if (stopAll) { resolve(new Error('stopped')); return; }
        if (passo >= passos) { i++; requestAnimationFrame(mover); return; }
        const x = atual.x + (dx * passo / passos);
        trator.style.transform = `translate(${x}px, ${yCentroLinha}px)`;
        passo++;
        requestAnimationFrame(animar);
      }

      requestAnimationFrame(animar);
    }

    mover();
  });
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// Buttons
document.addEventListener('click', (e) => {
  if (e.target === btnIniciar) iniciarCorrida();
});

async function iniciarCorrida() {
  if (emExecucao) return;
  emExecucao = true;
  stopAll = false;
  mensagem.textContent = 'üöú Tractors in motion‚Ä¶';

  // disable edits during the run
  linhas.forEach(l => l.style.pointerEvents = 'none');
  btnIniciar.disabled = true;

  try {
    // Traverse lines in parallel
    const promessas = tratores.map((tr, r) => percorrerLinha(tr, r));
    const resultados = await Promise.all(promessas.map(p => p.catch(e => e)));
    const fracassou = resultados.some(x => x && x.__fail);

    if (fracassou) {
      mensagem.textContent = '‚ùå One of the tractors found a crooked section!';
      criarBotaoReiniciarDinamico();
    } else {
      verificarVitoriaGlobal();
    }
  } finally {
    // Re-enable interactions
    linhas.forEach(l => l.style.pointerEvents = '');
    btnIniciar.disabled = false;
    emExecucao = false;
  }
}

// Initialization
criarLinhas();
</script>

</body>
</html>