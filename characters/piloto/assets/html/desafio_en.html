<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pilot Challenge ‚Äì 3 Towers and Light Beam</title>
<style>
  :root{
    --cell: 42px;
  }
  *{ box-sizing:border-box }
  html,body{ height:100% }
  body{
    margin:0; min-height:100svh; display:grid; place-items:center;
    background: radial-gradient(120% 200% at 50% 0%, rgba(255,255,255,.04), rgba(255,255,255,.02)), #0e152b;
    color:#e5e7eb; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  .wrap{ width:min(95vw, 1100px); display:grid; gap:12px; }
  h1{ margin:10px 0 0; text-align:center; font-size:clamp(20px,3.4vw,32px) }
  p.sub{ margin:0 0 8px; text-align:center; opacity:.9 }

  .panel{ padding:12px; border-radius:14px; background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
          border:2px solid rgba(255,255,255,.08); box-shadow:0 12px 30px rgba(0,0,0,.45); }

  .game{ display:grid; grid-template-columns: 1fr auto; gap:16px; align-items:center; }
  .play{
    position:relative; width: min(820px, 68vw); height: min(420px, 55vh);
    border-radius:12px; overflow:hidden;
    background: linear-gradient(180deg, #0b1226 0%, #0b1226 55%, #0b1226 100%);
    box-shadow: inset 0 0 0 2px rgba(255,255,255,.06), 0 10px 24px rgba(0,0,0,.4);
  }

  /* Towers */
  .lane{ position:absolute; top:0; bottom:0; width:33.3333%; display:grid; place-items:end center; }
  .lane:nth-child(1){ left:0; }
  .lane:nth-child(2){ left:33.3333%; }
  .lane:nth-child(3){ left:66.6666%; }

  .tower{ position:relative; width: calc(var(--cell)*1.6); height: calc(var(--cell)*3.4); border-radius:8px;
          background: linear-gradient(180deg, #1f2937, #111827);
          box-shadow: inset 0 0 0 2px rgba(255,255,255,.06), 0 10px 18px rgba(0,0,0,.45);
          display:grid; place-items:center; margin-bottom:10px; }
  .tower::before{ content:'üì°'; font-size: calc(var(--cell)*0.9); filter: drop-shadow(0 2px 6px rgba(0,0,0,.5)); }
  .controlled{ outline:3px solid #38bdf8; box-shadow:0 0 0 4px rgba(56,189,248,.25), 0 10px 18px rgba(0,0,0,.45); }

  /* Light beam */
  .beam{ position:absolute; left:50%; transform:translateX(-50%); top:-10%; width: 180px; height: 120%;
         background: radial-gradient(50% 60% at 50% 0%, rgba(250,204,21,.6) 0%, rgba(250,204,21,.25) 40%, rgba(250,204,21,0) 70%);
         filter: blur(1px); pointer-events:none; display:none; }
  .beam.show{ display:block; animation: pulse 1s ease-in-out infinite; }
  @keyframes pulse{ 0%,100%{opacity:.8} 50%{opacity:1} }

  /* HUD */
  .hud{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; justify-content:space-between; margin-top:6px; }
  .status{ font-weight:800 }
  .round{ opacity:.9 }

  .risk{ flex:1 1 220px; height:14px; background:#0b1224; border-radius:999px; overflow:hidden; border:1px solid rgba(255,255,255,.08); }
  .risk>i{ display:block; height:100%; width:0%; background: linear-gradient(90deg, #22c55e, #f59e0b 60%, #ef4444 100%); transition: width .12s linear; }

  /* Controles √† direita */
  .controls{ display:grid; grid-template-columns: repeat(1, 72px); gap:8px; justify-items:center; align-content:center; }
  .pad{ width:72px; height:72px; border-radius:14px; background:#111827; color:#e5e7eb; border:1px solid rgba(255,255,255,.08);
        display:grid; place-items:center; font-weight:900; font-size:20px; cursor:pointer; box-shadow:0 6px 14px rgba(0,0,0,.35) }
  .pad:active{ transform: translateY(1px) }
  .hint{ font-size:12px; opacity:.85; text-align:center; margin-top:6px }

  .btn{ border:0; padding:10px 14px; border-radius:10px; background:#38bdf8; color:#041019; font-weight:800; cursor:pointer; box-shadow:0 6px 16px rgba(0,0,0,.35) }
  .btn.secondary{ background:#94a3b8 }

  .win, .lose{ position:absolute; inset:0; display:none; place-items:center; background:radial-gradient(circle at 50% 50%, rgba(250,204,21,.10), rgba(0,0,0,.0)); }
  .win.show, .lose.show{ display:grid; }
  .win h2, .lose h2{ margin:0; text-shadow:0 6px 24px rgba(0,0,0,.55) }
  .lose h2{ color:#fecaca }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Pilot Challenge ‚Äì 3 Towers and Light Beam</h1>
    <p class="sub">Click the <b>antenna</b> to change the operated tower. Survive <b>6</b> rounds ‚Äî in some, there will be <b>two</b> towers lit at the same time!</p>

    <section class="panel">
      <div class="game">
        <div class="play" id="play">
          <!-- Lanes with towers -->
          <div class="lane"><div class="tower" id="tower0"></div><div class="beam" id="beam0"></div></div>
          <div class="lane"><div class="tower" id="tower1"></div><div class="beam" id="beam1"></div></div>
          <div class="lane"><div class="tower" id="tower2"></div><div class="beam" id="beam2"></div></div>

          <div class="win" id="win"><h2>‚ú® You resisted all the beams!</h2></div>
          <div class="lose" id="lose"><h2>‚ùå You stayed too long on the lit tower</h2></div>
        </div>

        <div class="controls" aria-label="controls">
          <button class="btn secondary" id="reset">Restart</button>
          <button class="btn" id="start">Start</button>
        </div>
      </div>

      <div class="hud">
        <div class="status" id="status">Ready!</div>
        <div class="round" id="round">Round 0/6</div>
        <div class="risk"><i id="riskbar"></i></div>
      </div>
    </section>
  </div>

<script>
(function(){
  const lanes = [0,1,2];
  const towers = lanes.map(i=> document.getElementById('tower'+i));
  const beams  = lanes.map(i=> document.getElementById('beam'+i));
  const riskEl = document.getElementById('riskbar');
  const statusEl = document.getElementById('status');
  const roundEl  = document.getElementById('round');
  const winEl = document.getElementById('win');
  const loseEl = document.getElementById('lose');
  const resetBtn = document.getElementById('reset');
  const startBtn = document.getElementById('start');

  let controlled = 1;              // tower under player control
  let lit = -1;                    // currently lit tower
  let active = false;
  let round = 0, totalRounds = 6;
  let risk = 0;                    // 0..1
  const riskUpPerSec = 0.20;       // ~5s to fill when in danger
  const riskDownPerSec = 0.55;     // emptying rate when safe

  // Sequence will be generated at each start: arrays with 1 or 2 towers
  let sequence = [];
  let durations = [];
  const ROUND_DURATION = 3.0;      // 3s each round

  let litSet = new Set();
  let staggerTO = null;            // timeout for 2nd beam (when it exists)

  // Initial UI
  setControlled(controlled);
  updateHUD();

  // choose towers with bias for currently controlled tower
  function pickOther(exclude){
    const opts = [0,1,2].filter(i=> i!==exclude);
    return opts[Math.floor(Math.random()*opts.length)];
  }
  function biasedPick(){
    const two = Math.random() < 0.4;            // ~40% of rounds with 2 beams
    const biasSingle = 0.7;                     // 70% chance to fall on active tower (1 beam)
    const biasIncludeControlledInTwo = 0.8;     // 80% chance to include active tower when 2 beams

    if(!two){
      const first = (Math.random() < biasSingle) ? controlled : pickOther(controlled);
      return [first];
    }
    // two beams in the round
    let a;
    if(Math.random() < biasIncludeControlledInTwo){
      a = controlled;
    } else {
      a = pickOther(controlled);
    }
    let b = pickOther(a); // ensures different from 'a'
    // second beam order will be delayed in time; keeping [a,b] is sufficient
    return [a,b];
  }

  // Click on antenna (tower) to take control
  towers.forEach((t,i)=> t.addEventListener('click', ()=> switchControl(i)) );

  function switchControl(idx){
    if(idx===controlled) return;
    towers[controlled].classList.remove('controlled');
    controlled = Math.max(0, Math.min(2, idx));
    towers[controlled].classList.add('controlled');
  }

  function setControlled(idx){
    controlled = idx; towers.forEach(t=> t.classList.remove('controlled')); towers[idx].classList.add('controlled');
  }

  document.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if(k==='1') switchControl(0);
    else if(k==='2') switchControl(1);
    else if(k==='3') switchControl(2);
    else if(k==='arrowleft' || k==='a') switchControl(Math.max(0, controlled-1));
    else if(k==='arrowright'|| k==='d') switchControl(Math.min(2, controlled+1));
  });

  // ===== Game loop =====
  let raf=null, last=0, roundTimer=0;

  function start(){
    if(active) return;
    reset(false);
    durations = Array.from({length: totalRounds}, ()=> ROUND_DURATION);

    active = true; round = 0; risk = 0; updateHUD();
    nextRound();
    last = performance.now();
    raf = requestAnimationFrame(tick);
  }

  function reset(hard=true){
    active = false; cancelAnimationFrame(raf); raf=null;
    if(staggerTO){ clearTimeout(staggerTO); staggerTO=null; }
    beams.forEach(b=> b.classList.remove('show'));
    lit = -1; litSet = new Set();
    risk = 0; riskEl.style.width = '0%';
    statusEl.textContent = 'Ready!';
    roundEl.textContent = 'Round 0/'+totalRounds;
    winEl.classList.remove('show');
    loseEl.classList.remove('show');
    setControlled(1);
    if(hard) {/* noop */}
  }

  function nextRound(){
    if(staggerTO){ clearTimeout(staggerTO); staggerTO=null; }
    if(round>=totalRounds){ win(); return; }

    // clear previous beams
    beams.forEach(b=> b.classList.remove('show'));

    // define lit towers in this round with bias
    const roundArr = biasedPick(); // [a] or [a,b]
    litSet = new Set();

    // turn on the first immediately
    const first = roundArr[0];
    litSet.add(first);
    beams[first].classList.add('show');

    const labelFirst = (first+1).toString();
    statusEl.textContent = `Beam on tower ${labelFirst}`;
    roundEl.textContent = `Round ${round+1}/${totalRounds}`;

    // schedule the second (if any) within the round duration
    roundTimer = durations[round];
    if(roundArr.length===2){
      const delay = Math.min(roundTimer-0.2, 1 + Math.random()*0.8); // ~1‚Äì1.8s
      if(delay>0.2){
        staggerTO = setTimeout(()=>{
          const second = roundArr[1];
          litSet.add(second);
          beams[second].classList.add('show');
          const label = [first+1, second+1].sort((a,b)=>a-b).join(' & ');
          statusEl.textContent = `Beam on tower ${label}`;
        }, delay*1000);
      }
    }
  }

  function tick(t){
    const dt = Math.max(0, (t - last)/1000);
    last = t;

    if(active){
      // risk fills if on lit tower; empties otherwise
      const danger = litSet.has(controlled);
      if(danger) risk = Math.min(1, risk + riskUpPerSec * dt);
      else       risk = Math.max(0, risk - riskDownPerSec * dt);
      riskEl.style.width = (risk*100).toFixed(1)+'%';
      if(risk>=1) return lose();

      // round timer
      roundTimer -= dt;
      if(roundTimer<=0){
        round++; nextRound();
      }
    }

    raf = requestAnimationFrame(tick);
  }

  function win(){
    active=false; beams.forEach(b=> b.classList.remove('show'));
    winEl.classList.add('show'); statusEl.textContent='‚≠ê Well done!';
  }
  function lose(){
    active=false; beams.forEach(b=> b.classList.remove('show'));
    loseEl.classList.add('show'); statusEl.textContent='‚ö†Ô∏è Excess on lit tower!';
  }

  // Buttons
  resetBtn.addEventListener('click', ()=> reset(true));
  startBtn.addEventListener('click', start);

  function updateHUD(){
    roundEl.textContent = `Round ${round}/${totalRounds}`;
    riskEl.style.width = (risk*100).toFixed(1)+'%';
  }
})();
</script>
</body>
</html>